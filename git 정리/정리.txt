blablabla파일 수정 후 저장 필수 제발 제발 제발 제발 까먹지 마라 넌 금붕어보다 똑똑해

Git을 배워야 하는 이유
Git은 VCS라는 종류의 프로그램 중 하나이다.
Version Controal System의 약자이고, 해당 기능을 사용하여 시간과 차원을 넘나들 수 있다.
Git으로 시간이동하기: 프로젝트의 버전을 과거로 되돌리거나 특정 내역을 취소할 수 있습니다.
Git으로 차원이동하기: 프로젝트의 여러 모드를 쉽게 전환하고 관리할 수 있습니다.

Git 기본설정
git bash를 설치 후 -> git —version -> 이후 git config --global core.autocrlf true 
sourceTree 설치 후 -> Bitbucket 건너뛰기, mercurial 건너뛰기
Vs code 설치 후 Ctrl + Shift + P를 눌러서 Select Default Profile 검색하기 -> git bash 선택 / Material Icon Theme을 선택하면 가독성이 높아진다.(선택사항)

git bash에서 
협업시 노출 이름: git config --global user.name "(본인 이름)" (github과는 별개)
협업시 노출 이메일: git config --global user.email "(본인 이메일)"(github과는 별개)
기본 브랜치명 변경: git config --global init.defaultBranch main
프로젝트를 진행할 최상위 폴더를 열고 거기서 git bash 실행, vs 터미널은 아까 방법으로 사용하고 폴더 탐색기에서 열려면 최상위 폴더 우클릭 -> 추가옵션 선택 -> git bash here
이후 git init -> .git 폴더 생성 
소스트리에서 저장소를 추가하려면 로컬 저장소 추가를 이용하기

vs code를 이용하여 코딩
.gitignore파일 생성 -> 무시할 파일 선택 https://git-scm.com/docs/gitignore (명령어 모음집)

시간 여행하기 
git status: 변경사항 확인하기
** untracked file= git의 관리에 들어간 적 없는 파일
git add 파일명: git에게 관리를 맡김
git add .: 모든 파일의 관리를 git에게 맡김
git commit: Vi 입력 모드로 진입 -> i누르고 입력시작 -> commit 이름 적고 :wq 입력해서 빠져나오기
추가 명령어, :q 저장 없이 종료 / :q! 입력한 것이 있을 때 사용 / :wq 입력한 것이 있을 때 사용 / k 위로 스크롤 / j 아래로 스크롤
그냥 git commit –m “(커밋 이름)”를 통해서도 커밋할 수 있다.(커밋 = create new version)
git commit –am “(커밋 이름)”은 add와 commit을 합친 명령어로 untracked file이 없을 때만 사용가능하다.
git log를 사용하여 CLI에서 변경사항을 확인하거나 소스트리를 사용하여 GUI에서 변경사항을 확인할 수 있다.

git에서 과거로 돌아가는 두 방식 
reset: 원하는 시점으로 돌아간 뒤 이후 내역들을 지웁니다.
git reset —hard “돌아갈 커밋 해쉬”
revert: 되돌리기 원하는 시점의 커밋을 거꾸로 실행합니다. 즉, revert한 version을 하나 더 만드는 것
git revert “커밋 해쉬” -> vi화면 -> :wq입력
협업할 때 reset을 사용하면 문제가 생길 수 있음, 문제가 생긴 version의 기록도 필요할 수 있기 때문에 이런 경우에는 revert를 사용한다.

소스트리에서 해보기 
스테이지에 올리기 = git add 
커밋에서 커밋 내용을 입력하고 올리면 끝
커밋 되돌리기 = revert
이 커밋까지 현재 브런치를 초기화 = reset (Hard로 선택)

git에서 차원 관리
Branch(=다른 차원)을 만드는 이유 -> 프로젝트를 하나 이상의 모습으로 관리해야 할 때(배포용, 테스트서버용, 개발용), 여러 작업들이 각각 독립되어 진행될 때(협업에서 기능을 분담할 때)
git branch (생성할 branch 이름)
git branch: 브랜치 목록 확인
git switch (branch name): 브랜치 바꾸기
git switch –c (새 브랜치명): 생성과 동시에 이동하기 / **checkout 명령어가 git 2.23버전부터 switch, restore로 분리
git branch –d (삭제할 브랜치명)
git branch –D (강제삭제할 브랜치명): 지워질 브랜치에만 있는 내용의 커밋이 있을 경우 즉 다른 브랜치로 가져오지 않은 내용이 있는 브랜치를 지울 때 사용한다.
git branch –m (기존 브랜치명) (새 브랜치명)

브랜치를 합치는 두 방식
merge: 두 브랜치를 한 커밋에 이어붙입니다.
브랜치 사용내역을 남길 필요가 있을 때 적합한 방식입니다.
git merge (branch name): 현재 브랜치에 (branch name)을 병합
merge시에 문제 발생: 동일 부분에서 다른 수정이 있는 branch의 경우 merge시 문제가 발생한다. 이때는 문제 부분으로 직접 돌아가서 선택을 해줘야 한다. 
해결이 어려울 경우 git merge —abort로 merge 중단 가능
해결 후에는 git add . -> git commit 기능 사용 가능

rebase: 브랜치를 다른 브랜치에 이어붙입니다.
한 줄로 깔끔히 정리된 내역을 유지하기 원할 때 적합합니다.
이미 팀원과 공유된 커밋들에 대해서는 사용하지 않는 것이 좋습니다.
git rebase (branch name): (branch name)의 끝에 현재 브랜치를 rebase
이 작업이 끝난다면 rebase한 branch는 해당 commit한 최신내용들이 모두 반영되어 있지만, (branch name)는 최신 commit이 반영되어 있지 않음 (보통 후자가 main이다)
이때 branch를 (branch name)으로 이동한 후 git merge (rebase한 branch)를 하면 해결이 된다.

Git hub란
같은 파일을 여럿이 수정해야 되는 상황에서 기존의 공유방식을 사용한다면 변경내용이 계속 덮어씌워질 수 있다. 깃헙에서는 커밋을 위해서는 최신 내용의 커밋을 먼저 다운로드 받아야 하는데, 이러한 방법을 사용한다면 협업이 가능하다.

가입하고 토큰 만들기: 보안을 위해 꼭 거쳐야 하는 단계이다.
profile -> setttings -> Developer Settings -> Personal access tokens -> Generate token -> 복사해서 개인적으로 저장해두기
토큰을 컴퓨터와 연동하기 
windows 자격 증명 관리자 -> windows 자격증명 선택 -> git:https://github.com 자격 정보 생성 -> 사용자명(깃헙 아이디 나의 경우에는 koyoungjun), 토큰 붙여넣기
sourcetree -> 옵션 -> 인증 -> 생성
GitHub에 새 Repository 생성 -> (public: 모두에게 보일 수 있는 프로젝트, Private: 허용된 인원만 볼 수 있는 프로젝트)
이후 Settings -> Collaborators -> Add people을 사용하여 팀원을 초대할 수 있다. 

git remote add origin (원격 저장소 주소): 로컬의 Git 저장소에 원격 저장소로의 연결 추가
git branch –M main: GitHub 권장 – 기본 브랜치명을 main으로
git push –u origin main: 로컬 자장소의 커밋 내역들 원격으로 push(업로드) / -u 또는 —set-upstream(현재 브랜치와 명시된 원격 브랜치 기본 연결)
git remote: 원격 목록 보기
git remote remove (origin 등 원격 이름)
Download ZIP: 파일들만 다운받음, Git 관리내역 제외
Git clone: Git 관리내역 포함 다운로드 -> 터미널이나 Git Bash에서 대상 폴더 이동 후 git clone (원격 저장소 주소)를 사용하여 원격 저장소에서 git을 불러올 수 있다.
git push: 지정된 원격 브런치로 커밋 올리기
원격에 먼저 적용된 새 버전이 있으면 사용 불가 -> pull을 먼저 하고 push 가능
git pull --no-rebase : merge 방식으로 받아오기
git pull --rebase: rebase 방식으로 받아오기
오류가 나면 merge나 rebase의 해결방식 그대로 해결하고, merge의 경우에는 git add .-> git commit -> Vi / rebase의 경우에는 git add . -> git rebase —continue -> git commit -> Vi 
원격에 문제가 생겨서 로컬의 git으로 대체해야 될 때는 git push —force를 사용하여 원격을 로컬의 상태로 만들 수 있다.(함부로 쓰면 욕먹는다. 조심하자)

원격의 브랜치 다루기
git push –u (원격 저장소 이름, 보통은 origin) (원격 브랜치 이름)
git branch —all: 브랜치 목록 보기(원격까지)
원격의 수정사항 받아오기 -> 원격에서 직접 브랜치를 생성한 경우 로컬에 반영되지 않을 수 있는데, 이 부분 해결
git fetch: 원격의 변경사항 확인
git switch –t origin/(원격에만 반영된 브랜치 이름): 로컬에 같은 이름의 브랜치를 생성하여 연결하고 switch
git push (원격 이름) --delete (원격의 브랜치명): 원격의 브랜치 삭제
sourcetree에서 로컬에 있는 브랜치를 원격에도 만들고 싶다면 push에서 체크박스에 체크한 채로 push하면 된다.
sourcetree에서 원격에 있는 브랜치를 로컬에도 만들고 싶다면 원격의 브랜치를 우클릭 한 다음에 체크아웃을 누르자.


git이 기존의 VCS들과 차별화된 점들
1. 델타 방식 vs 스냅샷 방식: 델타 방식은 각 버전에 모든 변경사항들을 저장해서 무거워진다. 스냅샷 방식은 각 버전에는 최신파일만 담겨있다.
2. 중앙집중식 버전 관리 vs 분산 버전 관리: 중앙집중식 버전 관리는 version database를 원격에 두기 때문에 원격에 의존하여 작업을 진행할 수 밖에 없다. 분산 버전 관리는 local에도 version database를 두기 때문에 로컬의 자유도가 높아진다. 

git의 3가지 공간
working directory -(add)-> staging area -(commit)-> repository
working directory에는 untracked file과 tracked file이 있다. untracked file은 Add된 적이 없는 파일이거나 ignore된 파일이다. tracked file은 Add 된적이 있고, 변경내용이 있는 파일이다. 즉, 이미 commit되어 repository에 있는 file 안에서 수정했을 때, 그 file이 tracked file의 형태로 working directory에 들어가게 된다.
여기서 git add 명령어로 staging area로 이동시킬 수 있다.
Staging area: commit을 위한 준비 단계
git commit 명령어로 repository로 이동시킬 수 있다.
뒤로 가기
git restore —staged (파일명)을 이용해서 staging aread서 working directory로 이동시킬 수 있다.
git restore을 이용하면 working directory에서 제거할 수 있다.

reset의 3가지 옵션
--soft: repository에서 staging area로 이동
--mixed (default): repository에서 working directory로 이동
--hard: 수정사항 완전히 삭제

Git의 HEAD: 현재 속한 브랜치의 가장 최신 커밋
git checkout HEAD^: ^갯수만큼 이전으로 이동한다.(~로도 됨)
git checkout -: 이동을 한 단계 되돌리기

HEAD를 사용하면 reset이나 revert와는 달리 원래의 브랜치에 영향을 주지 않고 과거의 파일 상태를 확인할 수 있다. *HEAD는 가장 최신 커밋을 나타내기에 과거로 간다는게 모순적으로 느낄 수 있는데, 익명의 새로운 브랜치를 만드는 방식으로 이동하는 것이기에 정의와 충돌하지 않는다.
git reset HEAD (원하는 단계) (옵션): HEAD 사용하여 reset하기

fetch와 pull의 차이
fetch: 원격 저장소의 최신 커밋을 로컬로 가져오기만 함
pull: 원격 저장소의 최신 커밋을 로컬로 가져와 merge 또는 rebase

fetch 한 내역 적용 전 살펴보기
원격의 브랜치에 커밋이 추가 되었을 때 -> git checkout origin/main으로 변경사항을 확인할 수 있다. (git fetch을 먼저 하고 진행해야 변경사항이 보인다.)
변경사항이 맘에 들었으면 local/main으로 이동 후 pull로 적용한다.
git checkout origin/(브랜치명)으로 원격의 새 브랜치를 확인할 수 있다.
git switch –t origin/(브랜치명)으로 원격의 새 브랜치와 동기화되는 브랜치를 local에도 생성하고 즉시 이동할 수 있다.

막힐 때
git help: 기본 명령어
git help –a: 모든 명령어
git (명령어) -h: 해당 명령어의 설명과 옵션 보기
git help (명령어): 해당 명령어의 설명과 옵션 웹사이트에서 보기
git (명령어) --help: 해당 명령어의 설명과 옵션 웹사이트에서 보기
https://git-scm.com/book/ko/v2 : git에서 만든 git에 관한 책(번역 잘 됨, 걍 영어공부를 해라 나태한 친구야)
https://git-scm.com/docs : git 정보 사이트

config를 —global과 함께 지정하면 전역으로 설정됩니다.
git config (global) --list: 현재 모든 설정값 보기
git config (global) -e: 에디터에서 보기(기본 값은 vi)
git config —global core.editor “code —wait”: 기본 에디터를 vscode로 수정
에디터 설정을 돌이키려면 git config —global –e -> [core] 부분 삭제하고 저장
android studio같은 editor에서는 지원하지 않는 기능이기도 하고, 어디서나 통용되는 vi기능에 익숙해지는 것이 필요함.
기본 명령어
git config --global core.autocrlf (윈도우: true / 맥: input): 줄바꿈 호환 문제 해결
pull 기본 전략 설정: git config pull.rebase (true/false)
git config --global init.defaultBranch main: 기본 브랜치명 설정
git config --global push.default current: push시 로컬과 동일한 브랜치명으로 설정 (git push –u를 사용하여 개인 지정도 가능함)

어떻게 커밋하는게 좋을까
하나의 커밋에는 한 단위의 작업을 넣자.(한 작업을 여러버전으로 쪼개거나, 여러 작업을 하나의 버전으로 뭉치면 안 됨)
커밋 메시지는 어떤 작업이 이뤄졌는지 알아볼 수 있도록 작성하자.

널리 사용되는 커밋 메시지 작성방식
type: subject

body (optional)
...
...
...

footer (optional)

(예시)
feat: 압축파일 미리보기 기능 추가

사용자의 편의를 위해 압축을 풀기 전에
다음과 같이 압축파일 미리보기를 할 수 있도록 함
 - 마우스 오른쪽 클릭
 - 윈도우 탐색기 또는 맥 파인더의 미리보기 창

Closes #125

Type 예시
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정
style: 공백, 세미콜론 등 스타일 수정
refactor: 코드 리팩토링
perf: 성능 개선
test: 테스트 추가
chore: 빌드 과정 또는 보조 기능(문서 생성기능 등) 수정
Subject: 커밋의 작업 내용 간략히 설명
Body: 길게 설명할 필요가 있을 시 작성
Footer: Breaking point가 있을 때, 특정 이슈에 대한 해결 작업일 때

https://gitmoji.dev/ 사이트를 이용한다면 type부분에 이모지를 사용할 수 있다.

보다 세심하게 스테이징하고 커밋하기
git add –p를 통해서 일부만 스테이징할 수 있다.
git commit –v을 통해서 일부만 커밋할 수 있다.
-> 이런 형식을 거친다면 로컬에서 한번에 같은 파일에서 수정한 내용이어도 다른 version으로 만들 수 있다.
git diff —staged(이번 commit에 담길 변경사항들 모아서 보여주기)와 commit기능을 합친게 git commit –v이다.

커밋하기 애매한 변화 치워두기 
git stash: 아래 명령어로 변경사항 치워두기
git stash pop: 원하는 시점, 브랜치에서 다시 적용
git stash –p: 원하는 것만 stash 하기
git stash –m “(text)”: 메시지와 함께 스태시
git stash list: 스태시 목록 보기
git stash apply: 치워둔 마지막 항목 적용( 끝에 번호로 항목 지정 가능 )
git stash drop: 치워둔 마지막 항목 삭제( 끝에 번호로 항목 지정 가능 ) 
git stash pop: pop = apply + drop
git stash branch (브랜치명): 새 브랜치를 생성한 뒤 pop하기
git stash clear: 치워둔 모든 항목들 비우기

커밋 수정하기
git commit —amend: 최근 커밋 내용 변경하기 -> vi editor로 변경하기
git commit --amend –m '(commit message)’를 사용하면 vi를 안 쓰고도 변경할 수 있다.

과거의 커밋 수정, 삭제, 병합, 분할
git rebase –i (수정 대상 바로 이전 커밋 해쉬) -> vi edit
명령어 p: 커밋 그대로 두기 / r: 커밋 메시지 변경 / e: 수정을 위해 정지 / d: 커밋 삭제 / s: 이전 커밋에 합치기
병합하는 방법: 병합 시킬 두 대상중 마지막 대상에 s 명령어 사용, 커밋 메시지가 두 개가 나오는데 하나만 남긴 후 수정하고 저장
분할하는 방법: e 명령어로 수정 시작 -> git reset HEAD~(mixed default) -> 변화들을 따로 스테이지 및 커밋하기 -> git rebase --continue

관리하지 않는 파일들 삭제하기
git clean을 사용하여 삭제할 수 있다.
-n: 삭제될 파일들 보여주기 / -i: 인터렉티브 모드 시작 / -d: 폴더 포함 / -f: 강제로 바로 지워버리기 / -x: .gitignore에 등록된 파일들도 삭제
위의 옵션들을 조합하여 사용할 수 있다.

커밋하지 않은 변경사항 되돌리기
git restore: 특정 파일을 지정된 상태로 복구
워킹 디렉토리의 특정 파일을 복구 : git restore (파일명)
변경상태를 스테이지에서 워킹 디렉토리로 돌려놓기 : git restore —staged(파일명)
파일을 특정 커밋의 상태로 되돌리기 : git restore —source=(헤드 또는 커밋 해시)파일명
	
리셋한걸 되돌리기
git reflog: 내가 한 모든 작업 내용을 볼 수 있다. -> 여기서 최근에 대량 리셋한 커밋의 해쉬를 복사 -> git reset —hard (해쉬)하면 되돌릴 수 있다. *화난다고 함부로 리셋하지 말자

git의 Tag: 특정 시점을 키워드로 저장하고 싶을 때, 커밋에 버전 정보를 붙이고자 할 때 
Tag의 종류: lightweight=특정 커밋을 가리키는 용도 / annotated=작성자 정보와 날짜, 메시지, GPG 서명 포함 가능
lightweight을 알아보자
git tag v2.0.0: 마지막 커밋에 태그 달기
git tag: 현존하는 태그 확인
git show v2.0.0: 원하는 태그의 내용 확인
git tag –d v2.0.0: 태그 삭제
git tag –a v2.0.0: 마지막 태그에 annotated 방식으로 태그하기이다. 
git tag v2.0.0 –m ‘(메시지 입력)’ 
원하는 커밋에 태그 달기
git tag (태그명) (커밋 해시) -m (메시지)
git tag –l ‘v1.*’: 필터링
git checkout v1.2.1: 원하는 버전으로 체크아웃

원격의 태그와 릴리즈
git push (원격명) (태그명): 특정 태그 원격에 올리기
git push —delete (원격명) (태그명): 특정 태그 원격에서 삭제
git push —tags: 로컬의 모든 태그 원격에 올리기
GitHub의 release: 다운로드 가능한 배포판 기능이다. -> GitHub의 Tag목록으로 들어감 -> 원하는 tag선택 후 Create release선택 -> 제목과 내용(.md형식)입력 후 Publish release

merge의 두가지 방법 Fastforward vs 3-way merge
Fastforward는 rebase이후 main의 HEAD와 rebase브랜치의 HEAD가 서로 맞지 않을 때 사용하는 방법이다. 두 브랜치가 특별한 분기점을 갖지 않고, 단순히 시점만 다를 뿐일 때 뒤쳐진 main의 HEAD를 최신으로 업데이트 해준다. 이걸 사용할 시 rebase의 branch는 삭제되기에 그 branch에서 어떤 일이 있었는지 알 수 없다.
3-way merge: merge를 하는 모든 과정을 남기고 합병할 때 추가 커밋을 하나 만든 뒤 merge한다.

다른 브랜치에서 원하는 커밋만 따오기 (=Cherry pick)
git cherry-pick (체리의 해시): rebase나 merge방식이 아니라 그 version만 복제해서 붙이는 개념이다. 즉 cherry-pick의 대상이 되는 version과 cherry-pick한 후의 version은 내용은 같지만 별개의 version이다.

다른 가지의 잔가지만 가져오기
https://www.yalco.kr/@git-github-dive/10-3/ 참고
git rebase --onto (도착 브랜치) (출발 브랜치) (이동할 브랜치) -> cirtus로 fast forward
reset은 브랜치별로 이뤄지는 것이기 때문에 브랜치가 합병된 경우에는 각각 리셋시켜야 한다. 위 사이트에 들어가서 구체적인 방법을 살펴보자.

다른 가지의 마디들 묶어서 가져오기
git merge —squash (대상 브랜치): 묶은 상태의 version을 따로 만드는 것, 기존의 브랜치는 그대로 남겨둔다. 즉, 엄밀하게 따지면 merge는 아님

실제 IT업계에서 프로젝트를 진행하는 흐름
https://nvie.com/posts/a-successful-git-branching-model/ 이 사이트 참고

log 더 자세히 알아보기
git log –p: 각 커밋마다의 변경사항 함께 보기
git log -(갯수): 최근 n개 커밋만 보기
git log —stat: 통계와 함께 보기
git log —oneline: 한 줄로 보기
#중요# git log –S (검색어): 변경사항 내 단어 검색
git log –grep (검색어): 커밋 메시지로 검색

차이 살펴보기
git diff: 워킹 디렉토리의 변경사항 확인
git diff —name-only: 파일명만 확인
git diff —staged: 스테이지의 확인
git diff (커밋1) (커밋2): 커밋간의 차이 확인
git diff (브랜치1) (브랜치2): 브랜치간의 차이 확인

누가 코딩했는지 알아내기
git blame (파일명): 파일의 부분별로 작성자 확인하기
git blame -L (시작줄) (끝줄, 또는 +줄수) (파일명): 특정 부분 지정해서 작성자 확인하기
VS Code의 GitLens 확장 프로그램을 사용하는걸 권장한다.

오류가 발생한 시점 찾아내기 
아이디어 = 이진 탐색 알고리즘
git bisect start: 이진 탐색 시작
git bisect bad: 오류발생 지점임을 표시
git checkout (해당 커밋 해시): 의심 지점으로 이동
git bisect good: 오류 발생 않을 시 양호함 표시
git bisect reset: 이진 탐색 종료

git hooks란 git상의 이벤트마다 자동으로 실행될 스크립트를 지정하는 것 
프로젝트 폴더 내 .git -> hooks 폴더 확인 -> 파일 끝에 .sample을 없애면 훅 실행파일이 된다. 
hook의 대표적인 예시로 gitmoji-cli가 있다. 

submodule: 프로젝트 폴더 안에 또 다른 프로젝트가 포함될 때 사용
-> git이 각 프로젝트마다 존재하며 각각은 독립적이다. 예를 들어 subproject안의 git은 main의 정보를 받지 못하며 main의 git은 subproject폴더 자체의 변경은 관리하지만 subproject폴더 안쪽에 있는 파일들의 변경은 관리하지 않는다. 
git submodule add (submodule의 GitHub 레포지토리 주소) (하위폴더명, 없을 시 생략): main-project에 서브모듈로 submodule추가하기
여기서 두 폴더에 모두 변경사항을 만들었다고 가정할 때, main의 변경사항을 먼저 commit한 후, submodule의 변경사항을 커밋하면, main-project가 working directory상태가 된다. -> submodule프로젝트 자체를 하나의 파일로 인식하기 때문에 -> 따라서 다시 커밋해야 됨

README.md -> 마크다운 문법을 사용해서 프로젝트에 대한 설명쓰기 -> 마크다운 문법은 급변하기 때문에 최신정보를 기준으로 작성하기

